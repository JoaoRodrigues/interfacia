<html>
  <head>
    <title>Interface Analysis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.12/d3.min.js"></script>
    <style type="text/css">
    	/* Containers */

   		/* Chord Styling */
		#circle circle {
		  fill: none;
		  pointer-events: all;
		}

		.group path {
		  fill-opacity: .5;
		}

		path.chord {
		  stroke: none;
		}

		#circle:hover path.fade {
		  display: none;
		}

		.chord_label {
			font-size: 0.75em;
		}


    </style>
  </head>
  <body>
  	<div id="chart"></div>
  	<div id="dataset-picker"></div>

	<script type='text/javascript'>
	
		// Load data
		var nodes = JSON.parse({{ nodes | tojson | safe }})
		var vdw_raw_data = JSON.parse({{ vdw_graph | tojson | safe }})
		var elec_raw_data = JSON.parse({{ elec_graph | tojson | safe }})
		var total_raw_data = JSON.parse({{ total_graph | tojson | safe }})
		var datasets = [ {"name": "van der Waals", "data": vdw_raw_data}, 
						 {"name": "Electrostatics", "data": elec_raw_data},
						 {"name": "Total Energy", "data": total_raw_data} ]

		// Function to scale raw data
		// Scales each data point to the % of *total* *absolute* energy
		// This means both highly favourable and unfavourable values will have similar percentages
		// Sort out between them using color.
		function scale_data(mtx) {
			var _abs_array = mtx.map(function (subArray) { return subArray.map(function (el) { return Math.abs(el) } ) })
			var _abs_total_ene = d3.sum(_abs_array.map(function (subArray) { return d3.sum(subArray) }))
			var _scaled_array = mtx.map(function (subArray) { return subArray.map(function (el) { return (Math.abs(el) / _abs_total_ene) } ) })

			var _flattened_raw_array = [].concat.apply([], mtx)
			var _flattened_scaled_array = [].concat.apply([], _scaled_array)
			var _mapping = []
			for (var i = 0; i < _flattened_raw_array.length; i++) {
				_mapping[_flattened_scaled_array[i]] = _flattened_raw_array[i]
			}

			return [_scaled_array, _mapping]
		};

    	// Setup SVG Canvas
		var width = 500,
		    height = 500,
		    outerRadius = Math.min(width, height) / 2 - 30,
		    innerRadius = outerRadius - 24;

		// Build color scale from energy values
		function get_color_scale(mtx) {
			var _flattened_array = [].concat.apply([], mtx)
			var extremes = d3.extent(_flattened_array)
			var c = d3.scale.linear()
					.domain([extremes[0], 0, extremes[1]])
					// .range(["blue", "white", "red"]) // Flat					
					.range(["#138BFF", "#fff", "#FF0007"]) // Vivid
					// .range(["#356089", "#fff", "#D1464A"]) // Pastel
			return c
		};

		// Create Plot
		var layout = d3.layout.chord()
		    .padding(.04)
		    .sortSubgroups(d3.descending)
		    .sortChords(d3.ascending);

		var arc_svg = d3.svg.arc()
		    .innerRadius(innerRadius)
		    .outerRadius(outerRadius);

		var path_svg = d3.svg.chord()
		    .radius(innerRadius);

		// Plotting function
		function plot(nodes, raw_data) {

			// Process Input Data
			var o = scale_data(raw_data);
			var scaled_data = o[0];
			var mapping = o[1];
			var colors = get_color_scale(raw_data);


			d3.select("#chart").selectAll('svg').remove(); // Clear 'canvas'
			
			var svg = d3.select("#chart").append("svg")
			    .attr("width", width)
			    .attr("height", height)
			  	.append("g")
			    .attr("id", "circle")
			    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
			
			svg.append("circle")
			    .attr("r", outerRadius);

			// Compute the chord/group layout
			layout.matrix(scaled_data);

			// Add a group per interface residue
			var group = svg.selectAll(".group")
				.data(layout.groups)
				.enter().append("g")
				.attr("class", "group")
				.on("mouseover", mouseover)
				.on("click", group_click)
		  		

		  	var group_path = group.append("path")
			  	.attr("id", function(d, i) { return "group" + i; })
			  	.attr("d", arc_svg)
			  	// Fill
			  	.style("fill", function(d, i) { 
			  						if (nodes[i].seg == 'A') {
			  							return "#006600"; } else {
			  								return "#ff9900";
			  							}
			  						})
			  	// Mouseover Title
			group_path.append("title").text(function(d, i) {
				return nodes[i].seg + ":" + nodes[i].resi + ":" + nodes[i].resn;
			});

			// Add a chord per interaction
			var chord = svg.selectAll(".chord")
				.data(layout.chords)
				.enter().append("path")
				.attr("class", "chord")
				.style("fill", function (d) { return colors(mapping[d.source.value]) })
				.attr("d", path_svg)
				.on("click", chord_click);
			
			// Add an elaborate mouseover title for each chord.
			chord.append("title").text(function(d) {
					return nodes[d.source.index].seg 
					+ ":" + nodes[d.source.index].resi 
					+ ":" + nodes[d.source.index].resn
			  	  	+ " â†’ " + nodes[d.target.index].seg 
			  	  	+ ":" + nodes[d.target.index].resi 
			  	  	+ ":" + nodes[d.target.index].resn
			   	 	+ ": " + mapping[d.source.value];
				});

			// Mouseover function to fade chords
			function mouseover(d, i) {
				chord.classed("fade", function(p) {
					return p.source.index != i
					&& p.target.index != i;
				});
			};

			// Clickers
			function group_click(d, i) {
				console.log(nodes[i])
			};

			function chord_click(d, i) {
				console.log(nodes[d.source.index], nodes[d.target.index])
			};

			// Ticks & Labels
			group.append("text")
				.each(function(d) { d.angle = (d.startAngle + d.endAngle) / 2; })
				.attr("class", "chord_label")
				.attr("dy", ".35em")
				.attr("transform", function(d) {
				return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
				    + "translate(" + (innerRadius + 26) + ")"
				    + (d.angle > Math.PI ? "rotate(180)" : "");
				})
				.style("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
				.text(function(d, i) { return nodes[i].resi; });

		};

		// Default to vdW data
		plot(nodes, vdw_raw_data);

		// Dataset switcher
		var dataset_picker = d3.select("#dataset-picker").selectAll(".dataset-button")
			.data(datasets);

		dataset_picker.enter()
			.append("input")
			.attr("value", function(d){ return "Dataset " + d.name })
			.attr("type", "button")
			.attr("class", "dataset-button")
			.on("click", function(d) {
				plot(nodes, d.data);
			});

		// Transitions
		// TODO

		// Ramp
		// TODO
    </script>
  </body>
</html>